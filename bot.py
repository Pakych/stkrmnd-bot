import logging
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup, WebAppInfo, ReplyKeyboardMarkup, KeyboardButton
from telegram.ext import Application, CommandHandler, MessageHandler, CallbackQueryHandler, ContextTypes, filters
from telegram.request import HTTPXRequest
from telegram.error import BadRequest
import os
import json
from dotenv import load_dotenv
from datetime import datetime

# Load environment variables
load_dotenv()

# Enable logging
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# Bot token
TOKEN = os.getenv('BOT_TOKEN')

# Admin IDs
ADMIN_IDS = [6053516349, 1991195848]  # Replace with actual admin IDs

# Web App URL
WEB_APP_URL = os.getenv("WEB_APP_URL", "https://pakych.github.io/stkrmnd-bot/?v=1.0.2")

# –ö–∞—Ç–µ–≥–æ—Ä—ñ—ó –¥–ª—è –∫–Ω–æ–ø–æ–∫
CATEGORIES = {
    "programming": "–ü—Ä–æ–≥—Ä–∞–º—É–≤–∞–Ω–Ω—è üíª",
    "design": "–î–∏–∑–∞–π–Ω üé®",
    "video": "–í—ñ–¥–µ–æ–º–æ–Ω—Ç–∞–∂ üé¨",
    "editing": "–†–µ–¥–∞–≥—É–≤–∞–Ω–Ω—è —Ñ–æ—Ç–æ üì∏",
    "other": "–Ü–Ω—à–µ üìù"
}

def get_main_keyboard():
    """Get main keyboard with web app button."""
    keyboard = [
        [KeyboardButton("üåê –í–µ–± –≤–µ—Ä—Å—ñ—è", web_app=WebAppInfo(url=WEB_APP_URL))],
        [KeyboardButton("üé® –î–∏–∑–∞–π–Ω"), KeyboardButton("üíª –ü—Ä–æ–≥—Ä–∞–º—É–≤–∞–Ω–Ω—è")],
        [KeyboardButton("üé¨ –í—ñ–¥–µ–æ–º–æ–Ω—Ç–∞–∂"), KeyboardButton("üì∏ –†–µ–¥–∞–≥—É–≤–∞–Ω–Ω—è —Ñ–æ—Ç–æ")],
        [KeyboardButton("üí∞ –ü—Ä–∞–π—Å")]
    ]
    return ReplyKeyboardMarkup(keyboard, resize_keyboard=True)

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Send a message when the command /start is issued."""
    user = update.effective_user
    
    # Initialize messages list in bot_data if not exists
    if 'messages' not in context.bot_data:
        context.bot_data['messages'] = []
    
    # Check if user is admin
    if user.id in ADMIN_IDS:
        keyboard = [
            [KeyboardButton("üåê –í–µ–± –≤–µ—Ä—Å—ñ—è", web_app=WebAppInfo(url=WEB_APP_URL))],
            [KeyboardButton("üì¨ –ü–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è"), KeyboardButton("üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞")],
            [KeyboardButton("üí∞ –ü—Ä–∞–π—Å")]
        ]
        reply_markup = ReplyKeyboardMarkup(keyboard, resize_keyboard=True)
        await update.message.reply_text(
            f"üëã –í—ñ—Ç–∞—é, {user.full_name}!\n\n"
            "üîë *–í–∏ —É–≤—ñ–π—à–ª–∏ —è–∫ –∞–¥–º—ñ–Ω—ñ—Å—Ç—Ä–∞—Ç–æ—Ä*\n\n"
            "–î–æ—Å—Ç—É–ø–Ω—ñ –∫–æ–º–∞–Ω–¥–∏:\n"
            "/messages - –ø–µ—Ä–µ–≥–ª—è–Ω—É—Ç–∏ –≤—Å—ñ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è\n"
            "/stats - –ø–µ—Ä–µ–≥–ª—è–Ω—É—Ç–∏ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É\n\n"
            "–í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ –∫–Ω–æ–ø–∫–∏ –Ω–∏–∂—á–µ –¥–ª—è –Ω–∞–≤—ñ–≥–∞—Ü—ñ—ó:",
            reply_markup=reply_markup,
            parse_mode='Markdown'
        )
        return

    keyboard = [
        [KeyboardButton("üåê –í–µ–± –≤–µ—Ä—Å—ñ—è", web_app=WebAppInfo(url=WEB_APP_URL))],
        [KeyboardButton("üé® –î–∏–∑–∞–π–Ω"), KeyboardButton("üíª –ü—Ä–æ–≥—Ä–∞–º—É–≤–∞–Ω–Ω—è")],
        [KeyboardButton("üé¨ –í—ñ–¥–µ–æ–º–æ–Ω—Ç–∞–∂"), KeyboardButton("üì∏ –†–µ–¥–∞–≥—É–≤–∞–Ω–Ω—è —Ñ–æ—Ç–æ")],
        [KeyboardButton("üí∞ –ü—Ä–∞–π—Å")]
    ]
    reply_markup = ReplyKeyboardMarkup(keyboard, resize_keyboard=True)
    
    await update.message.reply_text(
        f"üëã –í—ñ—Ç–∞—é, {user.full_name}!\n\n"
        "üé® *STKRMND Studio* - –≤–∞—à –Ω–∞–¥—ñ–π–Ω–∏–π –ø–∞—Ä—Ç–Ω–µ—Ä —É —Å—Ç–≤–æ—Ä–µ–Ω–Ω—ñ:\n"
        "‚Ä¢ –í–µ–±-—Å–∞–π—Ç—ñ–≤ —Ç–∞ –¥–æ–¥–∞—Ç–∫—ñ–≤\n"
        "‚Ä¢ –î–∏–∑–∞–π–Ω—É –±—É–¥—å-—è–∫–æ—ó —Å–∫–ª–∞–¥–Ω–æ—Å—Ç—ñ\n"
        "‚Ä¢ –í—ñ–¥–µ–æ–º–æ–Ω—Ç–∞–∂—É —Ç–∞ –∞–Ω—ñ–º–∞—Ü—ñ—ó\n"
        "‚Ä¢ –û–±—Ä–æ–±–∫–∏ —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ—ñ–π\n\n"
        "–í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ –∫–Ω–æ–ø–∫–∏ –Ω–∏–∂—á–µ –¥–ª—è –Ω–∞–≤—ñ–≥–∞—Ü—ñ—ó:",
        reply_markup=reply_markup,
        parse_mode='Markdown'
    )

async def handle_web_app_data(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Handle data received from web app."""
    try:
        data = json.loads(update.effective_message.web_app_data.data)
        msg_type = data.get('type')
        user = update.effective_user
        
        # Handle admin actions
        if msg_type == 'admin_action':
            if user.id not in ADMIN_IDS:
                await update.message.reply_text("‚ùå –£ –≤–∞—Å –Ω–µ–º–∞—î –ø—Ä–∞–≤ –¥–ª—è –≤–∏–∫–æ–Ω–∞–Ω–Ω—è —Ü—ñ—î—ó –¥—ñ—ó.")
                return
                
            action = data.get('action')
            message_id = data.get('messageId')
            
            if action == 'reply':
                reply_text = data.get('reply')
                try:
                    # Get the original message details from context.bot_data
                    original_message = next(
                        (msg for msg in context.bot_data.get('messages', []) if str(msg.get('id')) == str(message_id)),
                        None
                    )
                    if original_message:
                        user_id = original_message.get('user_id')
                        try:
                            await context.bot.send_message(
                                chat_id=user_id,
                                text=f"*–í—ñ–¥–ø–æ–≤—ñ–¥—å –≤—ñ–¥ STKRMND:*\n\n{reply_text}",
                                parse_mode='Markdown'
                            )
                            await update.message.reply_text("‚úÖ –í—ñ–¥–ø–æ–≤—ñ–¥—å –Ω–∞–¥—ñ—Å–ª–∞–Ω–æ —É—Å–ø—ñ—à–Ω–æ!")
                        except Exception as e:
                            logger.error(f"Error sending reply to user: {e}")
                            await update.message.reply_text("‚ùå –ù–µ –≤–¥–∞–ª–æ—Å—è –Ω–∞–¥—ñ—Å–ª–∞—Ç–∏ –≤—ñ–¥–ø–æ–≤—ñ–¥—å –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á—É.")
                    else:
                        await update.message.reply_text("‚ùå –ü–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ.")
                except Exception as e:
                    logger.error(f"Error processing reply: {e}")
                    await update.message.reply_text("‚ùå –ü–æ–º–∏–ª–∫–∞ –ø—Ä–∏ –æ–±—Ä–æ–±—Ü—ñ –≤—ñ–¥–ø–æ–≤—ñ–¥—ñ.")
                return
                
            elif action == 'mark_completed':
                try:
                    # Mark message as completed in context.bot_data
                    message = next(
                        (msg for msg in context.bot_data['messages'] if str(msg['id']) == str(message_id)),
                        None
                    )
                    if message:
                        message['completed'] = True
                        await update.message.reply_text("‚úÖ –ü–æ–∑–Ω–∞—á–µ–Ω–æ —è–∫ –≤–∏–∫–æ–Ω–∞–Ω–µ!")
                    else:
                        await update.message.reply_text("‚ùå –ü–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ.")
                except Exception as e:
                    logger.error(f"Error marking as completed: {e}")
                    await update.message.reply_text("‚ùå –ü–æ–º–∏–ª–∫–∞ –ø—Ä–∏ –ø–æ–∑–Ω–∞—á–µ–Ω–Ω—ñ —è–∫ –≤–∏–∫–æ–Ω–∞–Ω–µ.")
                return
        
        # Handle regular messages
        user_message = data.get('message')
        
        # Store message in context.bot_data
        message_id = len(context.bot_data['messages']) + 1
        message_data = {
            'id': message_id,
            'user_id': user.id,
            'username': user.username,
            'full_name': user.full_name,
            'type': msg_type,
            'message': user_message,
            'timestamp': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
            'completed': False
        }
        context.bot_data['messages'].append(message_data)
        
        # Format message for admin
        admin_message = f"""
üì© *–ù–û–í–ï –ü–û–í–Ü–î–û–ú–õ–ï–ù–ù–Ø*

üë§ *–í—ñ–¥:* {user.full_name}
üîç *Username:* @{user.username if user.username else '–Ω–µ–º–∞—î'}
üìã *–¢–∏–ø:* {msg_type}
üí≠ *–ü–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è:* {user_message}

üÜî Message ID: `{message_id}`
"""
        
        # Send to all admins
        for admin_id in ADMIN_IDS:
            try:
                await context.bot.send_message(
                    chat_id=admin_id,
                    text=admin_message,
                    parse_mode='Markdown'
                )
            except Exception as e:
                logger.error(f"Failed to send message to admin {admin_id}: {e}")
        
        # Send confirmation to user
        await update.message.reply_text(
            "‚úÖ *–î—è–∫—É—î–º–æ –∑–∞ –≤–∞—à–µ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è!*\n–ú–∏ –∑–≤'—è–∂–µ–º–æ—Å—è –∑ –≤–∞–º–∏ –Ω–∞–π–±–ª–∏–∂—á–∏–º —á–∞—Å–æ–º.",
            parse_mode='Markdown'
        )
    except Exception as e:
        logger.error(f"Error processing web app data: {e}")
        await update.message.reply_text(
            "‚ùå –í–∏–Ω–∏–∫–ª–∞ –ø–æ–º–∏–ª–∫–∞ –ø—Ä–∏ –æ–±—Ä–æ–±—Ü—ñ –≤–∞—à–æ–≥–æ –∑–∞–ø–∏—Ç—É. –°–ø—Ä–æ–±—É–π—Ç–µ –ø—ñ–∑–Ω—ñ—à–µ."
        )

async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Handle regular messages."""
    text = update.message.text
    user = update.effective_user
    
    # –Ø–∫—â–æ —Ü–µ –≤—ñ–¥–ø–æ–≤—ñ–¥—å –≤—ñ–¥ –∞–¥–º—ñ–Ω–∞ –Ω–∞ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è
    if user.id in ADMIN_IDS and update.message.reply_to_message:
        replied_msg = update.message.reply_to_message
        
        try:
            # –ó–Ω–∞—Ö–æ–¥–∏–º–æ ID –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –≤ —Ç–µ–∫—Å—Ç—ñ
            msg_id = None
            for line in replied_msg.text.split('\n'):
                if 'Message ID:' in line:
                    try:
                        # –í–∏–¥–∞–ª—è—î–º–æ –≤—Å—ñ —Å–∏–º–≤–æ–ª–∏ –∫—Ä—ñ–º —Ü–∏—Ñ—Ä
                        msg_id_str = ''.join(filter(str.isdigit, line))
                        if msg_id_str:
                            msg_id = int(msg_id_str)
                            break
                    except ValueError:
                        continue
            
            if msg_id is not None:
                # –ë–µ–∑–ø–µ—á–Ω–æ –æ—Ç—Ä–∏–º—É—î–º–æ —Å–ø–∏—Å–æ–∫ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω—å
                messages = context.bot_data.get('messages', [])
                original_msg = next(
                    (msg for msg in messages if msg.get('id') == msg_id),
                    None
                )
                
                if original_msg:
                    user_id = original_msg.get('user_id')
                    if user_id:
                        try:
                            await context.bot.send_message(
                                chat_id=user_id,
                                text=f"*–í—ñ–¥–ø–æ–≤—ñ–¥—å –≤—ñ–¥ STKRMND:*\n\n{text}",
                                parse_mode='Markdown'
                            )
                            await update.message.reply_text("‚úÖ –í—ñ–¥–ø–æ–≤—ñ–¥—å –Ω–∞–¥—ñ—Å–ª–∞–Ω–æ —É—Å–ø—ñ—à–Ω–æ!")
                        except Exception as e:
                            logger.error(f"Error sending reply to user: {e}")
                            await update.message.reply_text("‚ùå –ù–µ –≤–¥–∞–ª–æ—Å—è –Ω–∞–¥—ñ—Å–ª–∞—Ç–∏ –≤—ñ–¥–ø–æ–≤—ñ–¥—å –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á—É.")
                    else:
                        await update.message.reply_text("‚ùå –ù–µ –∑–Ω–∞–π–¥–µ–Ω–æ ID –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞.")
                else:
                    await update.message.reply_text("‚ùå –ü–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ.")
            else:
                await update.message.reply_text("‚ùå –ù–µ –∑–Ω–∞–π–¥–µ–Ω–æ ID –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è.")
        except Exception as e:
            logger.error(f"Error processing reply: {e}")
            await update.message.reply_text("‚ùå –ü–æ–º–∏–ª–∫–∞ –ø—Ä–∏ –æ–±—Ä–æ–±—Ü—ñ –≤—ñ–¥–ø–æ–≤—ñ–¥—ñ.")
        return

    # Handle regular messages
    if text == "üì¨ –ü–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è" and user.id in ADMIN_IDS:
        await admin_messages(update, context)
        return
    elif text == "üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞" and user.id in ADMIN_IDS:
        await admin_stats(update, context)
        return
    elif text == "üí∞ –ü—Ä–∞–π—Å":
        price_text = """
*üí∞ STKRMND | STUDIO ‚Äî –ü—Ä–∞–π—Å –ª–∏—Å—Ç*

*üé® –°—Ç–≤–æ—Ä–µ–Ω–Ω—è –µ–º–æ–¥–∑—ñ —Ç–∞ —Å—Ç—ñ–∫–µ—Ä –ø–∞–∫—ñ–≤:*
‚Ä¢ [–ï–º–æ–¥–∑—ñ —Ç–∞–∫–æ–≥–æ —Ç–∏–ø—É](https://t.me/addemoji/zahidsticker_by_fStikBot) ‚Äî *0,72$*
‚Ä¢ –ú—ñ–Ω—ñ –ø–∞–∫—É–Ω–æ–∫ (10 –µ–º–æ–¥–∑—ñ) ‚Äî *7,2$*
‚Ä¢ –ü–æ–≤–Ω–∏–π –ø–∞–∫—É–Ω–æ–∫ (40 –µ–º–æ–¥–∑—ñ) ‚Äî *28$*

*üé¨ –í—ñ–¥–µ–æ–º–æ–Ω—Ç–∞–∂:*
‚Ä¢ –ë–∞–∑–æ–≤–µ —Ä–µ–¥–∞–≥—É–≤–∞–Ω–Ω—è ‚Äî –≤—ñ–¥ *15$*
‚Ä¢ –ï–¥—ñ—Ç ‚Äî –≤—ñ–¥ *15$*
‚Ä¢ –ü–æ–≤–Ω–∏–π –º–æ–Ω—Ç–∞–∂ ‚Äî –≤—ñ–¥ *30$*

*üì∏ –†–µ–¥–∞–≥—É–≤–∞–Ω–Ω—è —Ñ–æ—Ç–æ:*
‚Ä¢ –ê–≤–∞—Ç–∞—Ä –ø—Ä–æ–µ–∫—Ç—É ‚Äî –≤—ñ–¥ *5$*
‚Ä¢ –û–±–∫–ª–∞–¥–∏–Ω–∫–∞ –ø—Ä–æ–µ–∫—Ç—É ‚Äî –≤—ñ–¥ *10$*
‚Ä¢ –ü—Ä–µ–≤'—é ‚Äî –≤—ñ–¥ *20$*

*üíª –†–æ–∑—Ä–æ–±–∫–∞:*
‚Ä¢ Telegram –±–æ—Ç–∏ ‚Äî –≤—ñ–¥ *50$*
‚Ä¢ –í–µ–±-—Å–∞–π—Ç–∏ ‚Äî –≤—ñ–¥ *200$*
‚Ä¢ –î–µ—Å–∫—Ç–æ–ø–Ω—ñ –ø—Ä–æ–≥—Ä–∞–º–∏ ‚Äî –≤—ñ–¥ *300$*

*üí° –ü—Ä–æ –ø–æ—Å–ª—É–≥–∏:*
‚Ä¢ –Ü–Ω–¥–∏–≤—ñ–¥—É–∞–ª—å–Ω–∏–π –ø—ñ–¥—Ö—ñ–¥ –¥–æ –∫–æ–∂–Ω–æ–≥–æ –ø—Ä–æ–µ–∫—Ç—É
‚Ä¢ –ë–µ–∑–∫–æ—à—Ç–æ–≤–Ω—ñ –ø—Ä–∞–≤–∫–∏
‚Ä¢ –ü—ñ–¥—Ç—Ä–∏–º–∫–∞ –ø—ñ—Å–ª—è –≤–∏–∫–æ–Ω–∞–Ω–Ω—è

*üìû –î–ª—è –¥–µ—Ç–∞–ª—å–Ω–æ–≥–æ –æ–±–≥–æ–≤–æ—Ä–µ–Ω–Ω—è –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ –≤–µ–±-—Ñ–æ—Ä–º—É –∞–±–æ –æ–±–µ—Ä—ñ—Ç—å –∫–∞—Ç–µ–≥–æ—Ä—ñ—é –≤ –º–µ–Ω—é.*
"""
        await update.message.reply_text(price_text, parse_mode='Markdown')
    elif text in ["üé® –î–∏–∑–∞–π–Ω", "üíª –ü—Ä–æ–≥—Ä–∞–º—É–≤–∞–Ω–Ω—è", "üé¨ –í—ñ–¥–µ–æ–º–æ–Ω—Ç–∞–∂", "üì∏ –†–µ–¥–∞–≥—É–≤–∞–Ω–Ω—è —Ñ–æ—Ç–æ"]:
        await update.message.reply_text(
            f"–û–ø–∏—à—ñ—Ç—å –≤–∞—à –ø—Ä–æ–µ–∫—Ç –¥–ª—è –∫–∞—Ç–µ–≥–æ—Ä—ñ—ó {text}.\n–Ø –ø–µ—Ä–µ–¥–∞–º –≤–∞—à–µ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –∞–¥–º—ñ–Ω—ñ—Å—Ç—Ä–∞—Ç–æ—Ä–∞–º.",
            reply_markup=get_main_keyboard()
        )
    else:
        # Store regular message in context.bot_data
        if 'messages' not in context.bot_data:
            context.bot_data['messages'] = []
            
        message_id = len(context.bot_data['messages']) + 1
        message_type = 'other'  # Default type for regular messages
        
        # Try to determine message type based on content
        if "–ø—Ä–æ–≥—Ä–∞–º" in text.lower():
            message_type = 'programming'
        elif "–¥–∏–∑–∞–π–Ω" in text.lower():
            message_type = 'design'
        elif "–≤—ñ–¥–µ–æ" in text.lower() or "–º–æ–Ω—Ç–∞–∂" in text.lower():
            message_type = 'video'
        elif "—Ñ–æ—Ç–æ" in text.lower() or "—Ä–µ–¥–∞–≥—É–≤–∞–Ω–Ω—è" in text.lower():
            message_type = 'editing'
        
        message_data = {
            'id': message_id,
            'user_id': user.id,
            'username': user.username,
            'full_name': user.full_name if user.full_name else "–ö–æ—Ä–∏—Å—Ç—É–≤–∞—á",
            'type': message_type,
            'message': text,
            'timestamp': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
            'completed': False
        }
        context.bot_data['messages'].append(message_data)
        
        # Format message for admin
        admin_message = f"""
üì© *–ù–û–í–ï –ü–û–í–Ü–î–û–ú–õ–ï–ù–ù–Ø*

üë§ *–í—ñ–¥:* {message_data['full_name']}
üîç *Username:* @{message_data['username'] if message_data['username'] else '–Ω–µ–º–∞—î'}
üìã *–¢–∏–ø:* {message_type}
üí≠ *–ü–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è:* {text}

üÜî Message ID: `{message_id}`
"""
        
        # Send to all admins
        for admin_id in ADMIN_IDS:
            try:
                await context.bot.send_message(
                    chat_id=admin_id,
                    text=admin_message,
                    parse_mode='Markdown'
                )
            except Exception as e:
                logger.error(f"Failed to send message to admin {admin_id}: {e}")
        
        # Send confirmation to user
        await update.message.reply_text(
            "‚úÖ *–î—è–∫—É—î–º–æ –∑–∞ –≤–∞—à–µ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è!*\n–ú–∏ –∑–≤'—è–∂–µ–º–æ—Å—è –∑ –≤–∞–º–∏ –Ω–∞–π–±–ª–∏–∂—á–∏–º —á–∞—Å–æ–º.",
            parse_mode='Markdown',
            reply_markup=get_main_keyboard()
        )

async def admin_messages(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Show messages to admin."""
    user_id = update.effective_user.id
    if user_id not in ADMIN_IDS:
        await update.message.reply_text("‚ùå –£ –≤–∞—Å –Ω–µ–º–∞—î –ø—Ä–∞–≤ –¥–ª—è –≤–∏–∫–æ–Ω–∞–Ω–Ω—è —Ü—ñ—î—ó –∫–æ–º–∞–Ω–¥–∏.")
        return

    if 'messages' not in context.bot_data:
        context.bot_data['messages'] = []
    
    messages = context.bot_data['messages']
    
    if not messages:
        await update.message.reply_text("üì≠ –ù–∞—Ä–∞–∑—ñ –Ω–µ–º–∞—î –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω—å.")
        return
        
    # Format messages
    message_text = "üì¨ *–û—Å—Ç–∞–Ω–Ω—ñ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è:*\n\n"
    for msg in messages[-10:]:  # Show last 10 messages
        status = "‚úÖ –í–∏–∫–æ–Ω–∞–Ω–æ" if msg.get('completed', False) else "‚è≥ –í –æ–±—Ä–æ–±—Ü—ñ"
        message_text += f"üë§ *–í—ñ–¥:* {msg['full_name']}\n"
        message_text += f"üì± *Telegram:* @{msg['username'] if msg['username'] else '–Ω–µ–º–∞—î'}\n"
        message_text += f"üìã *–ö–∞—Ç–µ–≥–æ—Ä—ñ—è:* {msg['type']}\n"
        message_text += f"üí¨ *–ü–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è:* {msg['message']}\n"
        message_text += f"‚è∞ *–ß–∞—Å:* {msg['timestamp']}\n"
        message_text += f"üìä *–°—Ç–∞—Ç—É—Å:* {status}\n"
        message_text += f"üÜî Message ID: `{msg['id']}`\n\n"
        message_text += "‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ\n\n"
    
    await update.message.reply_text(message_text, parse_mode='Markdown')

async def admin_stats(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Show statistics to admin."""
    user_id = update.effective_user.id
    if user_id not in ADMIN_IDS:
        await update.message.reply_text("‚ùå –£ –≤–∞—Å –Ω–µ–º–∞—î –ø—Ä–∞–≤ –¥–ª—è –≤–∏–∫–æ–Ω–∞–Ω–Ω—è —Ü—ñ—î—ó –∫–æ–º–∞–Ω–¥–∏.")
        return

    if 'messages' not in context.bot_data:
        context.bot_data['messages'] = []
    
    messages = context.bot_data['messages']
    
    # Calculate statistics
    total_messages = len(messages)
    completed_messages = sum(1 for msg in messages if msg.get('completed', False))
    pending_messages = total_messages - completed_messages
    
    # Count messages by type
    type_counts = {}
    for msg in messages:
        msg_type = msg.get('type', 'other')
        type_counts[msg_type] = type_counts.get(msg_type, 0) + 1
    
    # Format statistics message
    stats_text = "üìä *–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω—å:*\n\n"
    stats_text += f"üì® *–í—Å—å–æ–≥–æ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω—å:* {total_messages}\n\n"
    
    if type_counts:
        stats_text += "*–ü–æ –∫–∞—Ç–µ–≥–æ—Ä—ñ—è—Ö:*\n"
        for msg_type, count in type_counts.items():
            category_name = CATEGORIES.get(msg_type, msg_type.capitalize())
            stats_text += f"‚Ä¢ {category_name}: {count}\n"
        stats_text += "\n"
    
    stats_text += "*–°—Ç–∞—Ç—É—Å –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω—å:*\n"
    stats_text += f"‚úÖ –í–∏–∫–æ–Ω–∞–Ω–æ: {completed_messages}\n"
    stats_text += f"‚è≥ –í –æ–±—Ä–æ–±—Ü—ñ: {pending_messages}\n"
    
    await update.message.reply_text(stats_text, parse_mode='Markdown')

async def button_callback(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Handle button callbacks."""
    query = update.callback_query
    await query.answer()
    
    if query.data == 'messages':
        if query.from_user.id not in ADMIN_IDS:
            await query.message.reply_text("‚ùå –£ –≤–∞—Å –Ω–µ–º–∞—î –ø—Ä–∞–≤ –¥–ª—è –≤–∏–∫–æ–Ω–∞–Ω–Ω—è —Ü—ñ—î—ó –∫–æ–º–∞–Ω–¥–∏.")
            return
        await admin_messages(update, context)
    elif query.data == 'stats':
        if query.from_user.id not in ADMIN_IDS:
            await query.message.reply_text("‚ùå –£ –≤–∞—Å –Ω–µ–º–∞—î –ø—Ä–∞–≤ –¥–ª—è –≤–∏–∫–æ–Ω–∞–Ω–Ω—è —Ü—ñ—î—ó –∫–æ–º–∞–Ω–¥–∏.")
            return
        await admin_stats(update, context)

def main() -> None:
    """Start the bot."""
    application = Application.builder().token(TOKEN).build()

    # Add command handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("messages", admin_messages))
    application.add_handler(CommandHandler("stats", admin_stats))
    
    # Callback query handler
    application.add_handler(CallbackQueryHandler(button_callback))
    
    # Web app data handler
    application.add_handler(MessageHandler(filters.StatusUpdate.WEB_APP_DATA, handle_web_app_data))
    
    # Regular message handler
    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_message))

    # Run the bot until the user presses Ctrl-C
    application.run_polling(allowed_updates=Update.ALL_TYPES)

if __name__ == "__main__":
    main() 